= Eclipse JNoSQL databases
:toc: auto

The Eclipse JNoSQL Database API is a collection of implementations from the https://github.com/eclipse-ee4j/nosql[Jakarta NoSQL] specification.

== ArangoDB

image::https://jnosql.github.io/img/logos/ArangoDB.png[Arangodb Project,align="center"width=25%,height=25%]

https://www.arangodb.com/[ArangoDB] is a native multi-model database with flexible data models for documents, graphs, and key-values.
Build high performance applications using a convenient SQL-like query language or JavaScript extensions.

This API offers support for **Document** and **Key-Value** types.
The Graph is possible through Apache TinkerPop.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-arangodb</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```ArangoDBConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Arango Properties"]
|===
|Configuration property |Description

|`jnosql.jnosql.arangodb.host`
|The database host, where you need to put the port split by colons. E.g.: jnosql.jnosql.arangodb.host=localhost:8529

|`jnosql.arangodb.user`
|The user's userID.

|`jnosql.arangodb.password`
|The user's password

|`jnosql.arangodb.timeout`
|The connection and request timeout in milliseconds.

|`jnosql.arangodb.chuck.size`
|The chunk size when Protocol is used.

|`jnosql.arangodb.userSsl`
|The true SSL will be used when connecting to an ArangoDB server.

|`jnosql.arangodb.load.balancing.strategy`
|The com.arangodb.entity.LoadBalancingStrategy as String.

|`jnosql.arangodb.protocol`
|The com.arangodb.Protocol as String

|`jnosql.arangodb.connections.max`
|The maximum number of connections the built in connection pool will open per host.

|`jnosql.arangodb.acquire.host.list`
|Set hosts split by comma
|===

This is an example using ArangoDB's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.arangodb.communication.ArangoDBDocumentConfiguration
jnosql.document.database=<DATABASE>
jnosql.arangodb.host=localhost:8529
----

This is an example using ArangoDB's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.arangodb.communication.ArangoDBKeyValueConfiguration
jnosql.keyvalue.database=<DATABASE>
jnosql.arangodb.host=localhost:8529
----

The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<ArangoDBDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<ArangoDBDocumentManager> {

    @Produces
    public ArangoDBDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        ArangoDBDocumentConfiguration configuration = new ArangoDBDocumentConfiguration();
        ArangoDBDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Repository

The ```ArangoDBRepository``` interface is an extension of the Repository interface that allows execution of AQL via the ```@AQL``` annotation. Also, it's possible to combine with ```@Param``` annotation to execute parameterized AQL queries:

[source,java]
----
@Repository
interface PersonRepository extends ArangoDBRepository<Person, String> {

    @AQL("FOR p IN Person RETURN p")
    List<Person> findAll();

    @AQL("FOR p IN Person FILTER p.name = @name RETURN p")
    List<Person> findByName(@Param("name") String name);
}
----

=== @AQL

The ```@AQL``` annotation is a mapping annotation that allows to define dynamic queries following link:https://www.arangodb.com/docs/stable/aql/[ArangoDB Query Languange] on ```ArangoDBRepository```.

[source,java]
----
interface CarRepository extends ArangoDBRepository<Car, String> {

        @AQL("FOR c IN Car RETURN c")
        List<Car> findAll();

}
----

=== @Param

For parameterized queries, use the ```@Param``` annotation for binding the target argument to the parameter informing the named parameter like the below example:

[source,java]
----

interface OrderRepository extends ArangoDBRepository<Order, String> {

        @AQL("FOR o IN Order FILTER o.customer = @customer RETURN o")
        List<Order> findByCustomer(@Param("customer") String customer);

}
----


=== Template

The ```ArangoDBTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows using both synchronous and asynchronous AQL.

[source,java]
----
@Inject
private ArangoDBTemplate template;
...
List<Person> people = template.aql("FOR p IN Person FILTER p.name = @name RETURN p", params);
----


== Cassandra

image::https://jnosql.github.io/img/logos/cassandra.png[Apache Cassandra,align="center"width=25%,height=25%]

https://cassandra.apache.org/[Apache Cassandra] is a free and open-source distributed database management system designed to handle large amounts of data across many commodity servers, providing high availability with no single point of failure.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-cassandra</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```CassandraConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Cassandra"]
|===
|Configuration property |Description

|`jnosql.cassandra.user`
|The user's userID.

|`jnosql.cassandra.password`
|The user's password

|`jnosql.cassandra.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.cassandra.host.1=localhost

|`jnosql.cassandra.name`
|The name of the application using the created session.

|`jnosql.cassandra.port`
|The cassandra's port

|`jnosql.cassandra.query`
|The Cassandra CQL to execute when the configuration starts. It uses as a prefix. E.g.: jnosql.cassandra.query.1=<CQL>

|`jnosql.cassandra.data.center`
|The datacenter that is considered "local" by the load balancing policy.
|===

This is an example using Cassandra with MicroProfile Config.

[source,properties]
----
jnosql.column.provider=org.eclipse.jnosql.databases.cassandra.communication.CassandraConfiguration
jnosql.column.database=developers
jnosql.cassandra.query-1=<CQL-QUERY>
jnosql.cassandra.query.2=<CQL-QUERY-2>
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<CassandraColumnManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<CassandraColumnManager> {

    @Produces
    public CassandraColumnManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        CassandraConfiguration configuration = new CassandraConfiguration();
        CassandraColumnManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

=== Repository

The ```CassandraRepository``` interface is an extension of the ```Repository``` interface that allows execution of CQL and Consistency Level via the ```@CQL``` annotation.

[source,java]
----
@Repository
interface PersonRepository extends CassandraRepository<Person, String> {

    @CQL("select * from Person")
    List<Person> findAll();

    @CQL("select * from Person where name = ?")
    List<Person> findByName(String name);

    @CQL("select * from Person where age = :age")
    List<Person> findByAge(@Param("age") Integer age);
 }
----


=== @UDT

The ```@UDT``` annotation is a mapping annotation that allows defining a field to be stored as a user-defined type in Cassandra.

[source,java]
----
@Entity
public class Person {

    @Id("name")
    private String name;

    @Column
    private Integer age;

    @UDT("address")
    @Column
    private Address home;
 }
----

=== Converts

* TimestampConverter: That converts to/from java.util.Date
* LocalDateConverter: That converts to/from com.datastax.driver.core.LocalDate

[source,java]
----
    @Column
    @Convert(value = TimestampConverter.class)
    private LocalDateTime localDateTime;

    @Column
    @Convert(value = LocalDateConverter.class)
    private Calendar calendar;
----

=== Template

The ```CassandraTemplate``` interface is a specialization of ```ColumnTemplate``` interface that allows using CQL.

[source,java]
----
@Inject
CassandraTemplate template;
...
template.save(person, ConsistencyLevel.ONE);
----

== Couchbase

image::https://jnosql.github.io/img/logos/couchbase.svg[Couchbase Project,align="center"width=25%,height=25%]

The https://www.couchbase.com/[Couchbase] driver provides an API integration between Java and the database through a standard communication level.

This driver has support for two NoSQL API types: *Document* and *Key-Value*.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-couchbase</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```CouchbaseConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Couchbase"]
|===
|Configuration property |Description


|`jnosql.couchbase.host`
|The host at the database.

|`jnosql.couchbase.user`
|The user's userID.

|`jnosql.couchbase.password`
|The user's password

|`jnosql.couchbase.scope`
|The scope to use at couchbase otherwise, it will use the default.

|`jnosql.couchbase.collections`
|couchbase collection split by a comma. At the start-up of a CouchbaseConfiguration, there is this option to check if these collections exist; if not, it will create using the default settings.

|`jnosql.couchbase.collection`
|A default couchbase collection. When it is not defined the default value comes from Bucket.

|`jnosql.couchbase.index`
|A couchbase collection index. At the start-up of a {@link CouchbaseConfiguration}, it will read this property to check if the index does exist, if not it will create combined by scope and the database.


|===

This is an example using Couchbase's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.couchbase.communication.CouchbaseDocumentConfiguration
jnosql.document.database=heroes
jnosql.couchbase.host.1=localhost
jnosql.couchbase.user=root
jnosql.couchbase.password=123456
----

This is an example using Couchbase's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.database=heroes
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.couchbase.communication.CouchbaseKeyValueConfiguration
jnosql.couchbase.host.1=localhost
jnosql.couchbase.user=root
jnosql.couchbase.password=123456
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<CouchbaseDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<CouchbaseDocumentManager> {

    @Produces
    public CouchbaseDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        CouchbaseDocumentConfiguration configuration = new CouchbaseDocumentConfiguration();
        CouchbaseDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

=== Repository

The ```CouchbaseRepository``` interface is an extension of the ```Repository``` interface that allows execution of N1QL via the ```@N1QL``` annotation.


[source,java]
----
@Repository
interface PersonRepository extends CouchbaseRepository<Person, String> {

@N1QL("select * from Person")
List<Person> findAll();

@N1QL("select * from Person where name = $name")
List<Person> findByName(@Param("name") String name);

}
----


=== Template

The ```CouchbaseTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows using N1QL on both synchronous and asynchronous.

[source,java]
----
List<Person> people = template.n1qlQuery("select * from Person where name = $name", params);
----

== CouchDB

image::https://www.jnosql.org/img/logos/couchdb.png[CouchDB,align="center"width=25%,height=25%]

The https://couchdb.apache.org/[CouchDB] driver provides an API integration between Java and the database through a standard communication level.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-couchdb</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```CouchDBConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="CouchDB"]
|===
|Configuration property |Description

|`jnosql.couchdb.port`
|The port connection to a client connect. The default value is "5984"

|`jnosql.couchdb.max.connections`
|The max of connection that the couchdb client have. The default value is "20"

|`jnosql.couchdb.connection.timeout`
|The timeout in milliseconds used when requesting a connection. The default value is "1000".

|`jnosql.couchdb.socket.timeout`
|The socket timeout in milliseconds, which is the timeout for waiting for data or, put differently, a maximum period inactivity between two consecutive data packets). The default value is "10000".

|`jnosql.couchdb.max.object.size.bytes`
|The current maximum response body size that will be cached. The value is "8192".

|`jnosql.couchdb.max.cache.entries`
|The maximum number of cache entries the cache will retain. The default value is "1000".

|`jnosql.couchdb.host`
|The host at the database.

|`jnosql.couchdb.username`
|The user's userID.

|`jnosql.couchdb.password`
|The user's password

|`jnosql.couchdb.enable.ssl`
|If the request use a https or a http.

|`jnosql.couchdb.compression`
|Determines whether compressed entities should be decompressed automatically.

|===

This is an example using CouchDB's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.couchdb.communication.CouchDBDocumentConfiguration
jnosql.document.database=heroes
jnosql.couchdb.host=localhost
jnosql.couchdb.username=admin
jnosql.couchdb.password=password
----

== Elasticsearch

image::https://jnosql.github.io/img/logos/elastic.svg[Elasticsearch Project,align="center"width=25%,height=25%]

https://www.elastic.co/[Elasticsearch] is a search engine based on Lucene.
It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents.
Elasticsearch is developed in Java and is released as open source under the terms of the Apache License.
Elasticsearch is the most popular enterprise search engine followed by Apache Solr, also based on Lucene.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-elasticsearch</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```ElasticsearchConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Elasticsearch"]
|===
|Configuration property |Description

|`jnosql.elasticsearch.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.elasticsearch.host.1=172.17.0.2:1234

|`jnosql.elasticsearch.user`
|The user's userID.

|`jnosql.elasticsearch.password`
|The user's password

|===

This is an example using Elasticsearch's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.elasticsearch.communication.ElasticsearchDocumentConfiguration
jnosql.document.database=developers
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<ElasticsearchDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<ElasticsearchDocumentManager> {

    @Produces
    public ElasticsearchDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        ElasticsearchDocumentConfiguration configuration = new ElasticsearchDocumentConfiguration();
        ElasticsearchDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Template

The ```ElasticsearchTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows using a search engine on both synchronous and asynchronous.

[source,java]
----
@Inject
ElasticsearchTemplate template;
...

QueryBuilder queryBuilder = boolQuery().filter(termQuery("name", "Ada"));
List<Person> people = template.search(queryBuilder, "Person");
----

== Hazelcast

image::https://jnosql.github.io/img/logos/hazelcast.svg[Hazelcast Project,align="center" width=25%,height=25%]

https://hazelcast.com/[Hazelcast] is an open source in-memory data grid based on Java.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-hazelcast</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```HazelcastConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Hazelcast"]
|===
|Configuration property |Description

|`jnosql.hazelcast.instance.name`
|The instance name uniquely identifying the hazelcast instance created by this configuration. This name is used in different scenarios, such as identifying the hazelcast instance when running multiple instances in the same JVM.

|`jnosql.hazelcast.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.hazelcast.host.1=localhost

|`jnosql.hazelcast.port`
|The database port

|`jnosql.hazelcast.port.count`
|The maximum number of ports allowed to use.

|`jnosql.hazelcast.port.auto.increment`
|Sets if a Hazelcast member is allowed to find a free port by incrementing the port number when it encounters an occupied port.

|`jnosql.hazelcast.multicast.enable`
|Enables or disables the multicast discovery mechanism

|`jnosql.hazelcast.tcp.ip.join`
|Enables or disables the Tcp/Ip join mechanism.

|===

This is an example using Hazelcast's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.hazelcast.communication.HazelcastKeyValueConfiguration
jnosql.keyvalue.database=heroes
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<HazelcastBucketManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<HazelcastBucketManager> {

    @Produces
    public HazelcastBucketManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        HazelcastKeyValueConfiguration configuration = new HazelcastKeyValueConfiguration();
        HazelcastBucketManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Repository

[source,java]
----
@Repository
interface PersonRepository extends HazelcastRepository<Person, String> {

        @Query("active")
        List<Person> findActive();

        @Query("name = :name AND age = :age")
        Set<Person> findByAgeAndInteger(@Param("name") String name, @Param("age") Integer age);
    }
----

=== Template

The ```HazelcastTemplate``` interface is a specialization of the ```KeyValueTemplate``` interface that allows execution of a Hazelcast query.

[source,java]
----
Collection<Person> people = template.query("active");
Collection<Person> people2 = template.query("age = :age", singletonMap("age", 10));
Collection<Person> people3 = template.query(Predicates.equal("name",  "Poliana"));
----

== HBase

image::https://jnosql.github.io/img/logos/hbase.png[Hbase Project,align="center" width=25%,height=25%]

https://hbase.apache.org/[HBase] is an open source, non-relational, distributed database modeled after Google's BigTable and is written in Java.

This driver provides support for the *Column Family* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-hbase</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```HbaseConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="HBase"]
|===
|Configuration property |Description

|`jnosql.hbase.family`
|The Column family prefixes. E.g.: jnosql.hbase.family.1=<FAMILY>

|===

This is an example using HBase's *Column Family* NoSQL API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.hbase.communication.HBaseColumnConfiguration
jnosql.column.database=heroes
----

== Infinispan

image::https://jnosql.github.io/img/logos/infinispan.svg[Infinista Project,align="center" width=25%,height=25%]

https://infinispan.org/[Infinispan] is a distributed in-memory key/value data store with optional schema, available under the Apache License 2.0.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-infinispan</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```InfinispanConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Infinispan"]
|===
|Configuration property |Description

|`jnosql.infinispan.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.infinispan.host.1=HOST

|`jnosql.infinispan.config`
|The Infinispan configuration path. E.g.: jnosql.infinispan.config=infinispan.xml

|===

This is an example using Infinispan's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.infinispan.communication.InfinispanKeyValueConfiguration
jnosql.keyvalue.database=heroes
jnosql.infinispan.config=infinispan.xml
----

== Memcached

image::https://www.jnosql.org/img/logos/memcached.png[Memcached Project,align="center" width=25%,height=25%]

https://memcached.org/[Memcached] is a general-purpose distributed memory caching system.
It is often used to speed up dynamic database-driven websites by caching data and objects in RAM to reduce the number of times an external data source (such as a database or API) must be read.
Memcached is free and open-source software, licensed under the Revised BSD license.
Memcached runs on Unix-like operating systems (at least Linux and OS X) and on Microsoft Windows.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-memcached</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```MemcachedConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Memcached"]
|===
|Configuration property |Description

|`jnosql.memcached.daemon`
|The daemon state of the IO thread (defaults to true).

|`jnosql.memcached.reconnect.delay`
|The maximum reconnect delay

|`jnosql.memcached.protocol`
|The protocol type  net.spy.memcached.ConnectionFactoryBuilder.Protocol

|`jnosql.memcached.locator`
|The locator type net.spy.memcached.ConnectionFactoryBuilder.Locator

|`jnosql.memcached.auth.wait.time`
|Custom wait time for the authentication on connect/reconnect.

|`jnosql.memcached.max.block.time`
|The maximum amount of time (in milliseconds) a client is willing to wait for space to become available in an output queue.

|`jnosql.memcached.timeout`
|The default operation timeout in milliseconds.

|`jnosql.memcached.read.buffer.size`
|The read buffer size.

|`jnosql.memcached.should.optimize`
|The default operation optimization is not desirable.

|`jnosql.memcached.timeout.threshold`
|The maximum timeout exception threshold.

|`jnosql.memcached.nagle.algorithm`
|Enable the Nagle algorithm.

|`jnosql.memcached.user`
|The user's userID

|`jnosql.memcached.password`
|The user's password.

|`jnosql.memcached.host`
|Database's host. It is a prefix to enumerate hosts. E.g.: jnosql.memcached.host.1=localhost:11211

|===

This is an example using Memcached's Document API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.memcached.communication.MemcachedKeyValueConfiguration
jnosql.keyvalue.database=heroes
jnosql.memcached.host.1=localhost:11211
----

== MongoDB

image::https://jnosql.github.io/img/logos/mongodb.png[MongoDB Project,align="center" width=25%,height=25%]

https://www.mongodb.com/[MongoDB] is a free and open-source cross-platform document-oriented database program.
Classified as a NoSQL database program, MongoDB uses JSON-like documents with schemas.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-mongodb</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```MongoDBDocumentConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="MongoDB"]
|===
|Configuration property |Description

|`jnosql.mongodb.host`
|The database host as prefix. E.g.: mongodb.host.1=localhost:27017

|`jnosql.mongodb.user`
|The user's userID.

|`jnosql.mongodb.url`
|MongoDB's connection string

|`jnosql.mongodb.password`
|The user's password

|`jnosql.mongodb.authentication.source`
|The source where the user is defined.

|`jnosql.mongodb.authentication.mechanism`
|Authentication mechanisms com.mongodb.AuthenticationMechanism

|===

This is an example using Mongodb's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.database=olympus
jnosql.mongodb.host=localhost:27017
jnosql.document.provider=org.eclipse.jnosql.databases.mongodb.communication.MongoDBDocumentConfiguration
----

The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<MongoDBDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<MongoDBDocumentManager> {

    @Produces
    public MongoDBDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        MongoDBDocumentConfiguration configuration = new MongoDBDocumentConfiguration();
        MongoDBDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----


=== Converter

In this extension, you have the option to convert to/from the MongoDB ```ObjectID```.

[source,java]
----
@Entity
public class Music {

    @Id
    @Convert(ObjectIdConverter.class)
    private String id;

}
----

== OrientDB

image::https://jnosql.github.io/img/logos/orientdb.png[Orient Project,align="center" width=25%,height=25%]

https://orientdb.org/[OrientDB] is an open source NoSQL database management system written in Java.
It is a multi-model database, supporting graph, document, key/value, and object models, but the relationships are managed as in graph databases with direct connections between records.
It supports schema-less, schema-full and schema-mixed modes.
It has a strong security profiling system based on users and roles and supports querying with Gremlin along with SQL extended for graph traversal.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-orientdb</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```OrientDBDocumentConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="OrientDB"]
|===
|Configuration property |Description

|`jnosql.orientdb.host`
|The database host

|`jnosql.orientdb.user`
|The user's userID.

|`jnosql.orientdb.password`
|The user's password

|`jnosql.orientdb.storage.type`
|The storage type com.orientechnologies.orient.core.db.ODatabaseType

|===

This is an example using OrientDB's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.orientdb.communication.OrientDBDocumentConfiguration
jnosql.document.database=heroes
jnosql.orientdb.host=localhost:27017
jnosql.orientdb.user=root
jnosql.orientdb.password=rootpwd
jnosql.orientdb.storageType=plocal
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<OrientDBDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<OrientDBDocumentManager> {

    @Produces
    public OrientDBDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        OrientDBDocumentConfiguration configuration = new OrientDBDocumentConfiguration();
        OrientDBDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

=== Repository

The ```OrientDBCrudRepository``` interface  is an extension of the ```Repository``` interface that allows execution of a SQL Query via the ```@SQL``` annotation.

[source,java]
----
@Repository
    interface PersonRepository extends OrientDBCrudRepository<Person, String> {

        @SQL("select * from Person")
        List<Person> findAll();

        @SQL("select * from Person where name = ?")
        List<Person> findByName(String name);

        @SQL("select * from Person where age = :age")
        List<Person> findByAge(@Param("age") Integer age);
    }
----

=== Template

The ```OrientDBTemplate``` interface is a specialization of the ```DocumentTemplate``` interface that allows execution of a SQL query and live query on both synchronous and asynchronous.

[source,java]
----
@Inject
OrientDBTemplate template;
...

Stream<Person> stream = template.sql("select * from Person where name = ?", "Ada");
template.live("select from Person where name = ?", callBack, "Ada");
----

== RavenDB

image::https://www.jnosql.org/img/logos/ravendb.png[RavenDB Project,align="center",align="center" width=50%,height=50%]

https://ravendb.net/[RavenDB] is a fully Transactional Open Source NoSQL Document Database.
Easy to use, rapidly scalable, offers high availability, and takes your Business into the Next Generation of Data Performance.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-ravendb</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```RavenDBConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="RavenDB"]
|===
|Configuration property |Description

|`jnosql.ravendb.host`
|The database host

|===

This is an example using RavenDB's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.ravendb.communication.RavenDBDocumentConfiguration
jnosql.document.database=heroes
----

== Redis

image::https://jnosql.github.io/img/logos/redis.png[Redis Project,align="center" width=25%,height=25%]

https://redis.com/[Redis] is a software project that implements data structure servers.
It is open-source, networked, in-memory, and stores keys with optional durability.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-redis</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```RedisConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Redis"]
|===
|Configuration property |Description

|`jnosql.redis.host`
|The database host

|`jnosql.redis.port`
|The database port

|`jnosql.redis.timeout`
|The redis timeout, the default value 2000 on milliseconds

|`jnosql.redis.password`
|The user's password

|`jnosql.redis.database`
|The redis database number, the default value is 0

|`jnosql.redis.client.name`
|The client's name

|`jnosql.redis.max.total`
|The value for the maxTotal configuration attribute for pools created with this configuration instance, the default value 1000.

|`jnosql.redis.max.idle`
|The value for the maxIdle configuration attribute for pools created with this configuration instance, the default value 10.

|`jnosql.redis.min.idle`
|The value for the minIdle configuration attribute for pools created with this configuration instance, the default value 1.

|`jnosql.redis.max.wait.millis`
|The value for the maxWait configuration attribute for pools created with this configuration instance, the default value 3000.

|===

This is an example using Redis's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.redis.communication.RedisConfiguration
jnosql.keyvalue.database=heroes
----

== Riak

image::https://jnosql.github.io/img/logos/riak.png[Riak Project,align="center" width=25%,height=25%]

https://riak.com/[Riak] (pronounced "ree-ack") is a distributed NoSQL key-value data store that offers high availability, fault tolerance, operational simplicity, and scalability.
In addition to the open-source version, it comes in a supported enterprise version and a cloud storage version.

This driver provides support for the *Key-Value* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-redis</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```RiakConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Riak"]
|===
|Configuration property |Description

|`jnosql.riak.host`
|The database host

|===

This is an example using Riak's Key-Value API with MicroProfile Config.

[source,properties]
----
jnosql.keyvalue.provider=org.eclipse.jnosql.databases.riak.communication.RiakKeyValueConfiguration
jnosql.keyvalue.database=heroes
----

== Solr

image::https://jnosql.github.io/img/logos/solr.svg[Apache Solr Project,align="center" width=25%,height=25%"]

https://solr.apache.org/[Solr] is an open-source enterprise-search platform, written in Java, from the Apache Lucene project.
Its major features include full-text search, hit highlighting, faceted search, real-time indexing, dynamic clustering, database integration, NoSQL features and rich document (e.g., Word, PDF) handling.
Providing distributed search and index replication, Solr is designed for scalability and fault tolerance.
Solr is widely used for enterprise search and analytics use cases and has an active development community and regular releases.

This driver provides support for the *Document* NoSQL API.

=== How To Install

You can use either the Maven or Gradle dependencies:

[source,xml]
----
<dependency>
  <groupId>org.eclipse.jnosql.databases</groupId>
  <artifactId>jnosql-solr</artifactId>
  <version>1.0.0-b6</version>
</dependency>
----

=== Configuration

This API provides the ```SolrDocumentConfigurations``` class to programmatically establish the credentials.
Please note that you can establish properties using the https://microprofile.io/microprofile-config/[MicroProfile Config] specification.

[cols="Solr"]
|===
|Configuration property |Description

|`jnosql.solr.host`
|Database's host. E.g.: jnosql.solr.host=http://localhost:8983/solr/

|`jnosql.solr.user`
|The user's userID.

|`jnosql.solr.password`
|The user's password

|`jnosql.solr.automatic.commit`
|Define if each operation Apache Solr will commit automatically, true by default.

|===

This is an example using Solr's Document API with MicroProfile Config.

[source,properties]
----
jnosql.document.provider=org.eclipse.jnosql.databases.solr.communication.SolrDocumentConfiguration
jnosql.document.database=heroes
----


The config settings are the default behavior; nevertheless, there is an option to do it programmatically. Create a class that implements the `Supplier<SolrDocumentManager>` and then defines it as an `@Alternative` and the `Priority`.

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier<SolrDocumentManager> {

    @Produces
    public SolrDocumentManager get() {
        Settings settings = Settings.builder().put("credential", "value").build();
        SolrDocumentConfiguration configuration = new SolrDocumentConfiguration();
        SolrDocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("database");
    }
}
----

=== Repository

The ```SolrRepository``` interface is an extension of the ```Repository``` interface that allows using Solr query annotation that executes Solr query.

[source,java]
----
@Repository
interface PersonRepository extends SolrRepository<Person, String> {

    @Solr("select * from Person")
    List<Person> findAll();

    @Solr("select * from Person where name = $name")
    List<Person> findByName(@Param("name") String name);
}
----

=== Template

The ```SolrTemplate``` interface is a specialization of the ```DocumentTemplate``` that allows execution of a Solr query.

[source,java]
----
@Inject
SolrTemplate template;
...
List<Person> people = template.solr("age:@age AND type:@type AND _entity:@entity", params);
----

== Getting Help

Having trouble with Eclipse JNoSQL databases? Weâ€™d love to help!

Please report any bugs, concerns or questions with Eclipse JNoSQL databases to https://github.com/eclipse/jnosql[https://github.com/eclipse/jnosql].
Follow the instructions in the templates and remember to mention that the issue refers to JNoSQL databases.

== Contributing

We are very happy you are interested in helping us and there are plenty ways you can do so.

- https://github.com/eclipse/jnosql/issues[**Open an Issue:**]  Recommend improvements, changes and report bugs. Please, mention that the issue refers to the JNoSQL databases project.

- **Open a Pull Request:** If you feel like you can even make changes to our source code and suggest them, just check out our link:CONTRIBUTING.adoc[contributing guide] to learn about the development process, how to suggest bugfixes and improvements.

== Integration tests

The integration tests on databases primarily integrate with the https://www.testcontainers.org/[Testcontainers], requiring a more powerful computer.

Those tests are disabled by default; thus, if you want to run only the integration tests:

[source,bash]
----
mvn test -Djnosql.test.integration=true
----

To create integration tests on this project, we're using EnabledIfSystemProperty from JUnit Jupiter, where the system property is: `jnosql.test.integration`, and we expected `true` to execute.

We, the `IntegrationTest` structure class, hold this content, considering using it on the new integration tests.

[source,java]
----
import static org.eclipse.jnosql.communication.driver.IntegrationTest.NAMED;
import static org.eclipse.jnosql.communication.driver.IntegrationTest.MATCHES;

@EnabledIfSystemProperty(named = NAMED, matches = MATCHES)
class IntegrationSampleTest {

}
----

== Want to Contribute a New Driver?

As an open-source project, you're free to create any driver, and you're welcome to join and participate in the process.
To add a new driver, we have a few requirements:

* Run Java 17
* Include the documentation driver in the README file.
* Cover the driver with tests and preferences with TestContainer.
* Please pay attention to the documentation. This includes JavaDoc
* Include a class to represent and contain the properties. In general, those are `enum`
** A nomenclature is the <DATABASE>Configurations, e.g., CassandraConfigurations, MongoDBConfigurations.
** The package name will follow the terminology: `org.jnosql.databases.[DATABASE].[LAYER]`
*** E.g., Give a database called "Ada" that is a column type, the package name will be: `org.eclipse.jnosql.databases.ada.communication` for the driver layer and `org.eclipse.jnosql.databases.ada.mapping` for the mapping.
*** You can include the database in a single project if a NoSQL supports multiple database types.
* It is crucial to have an integration test with the database; please annotate those `EnabledIfSystemProperty` and check the integration session to know more.
* Create a `Supplier` class on the mapping layer that will produce a specific Manager instance using Microprofile. Check: `ColumnManagerSupplier`, `DocumentManagerSupplier` classes to get more information.



== Graph Drivers

Eclipse JNoSQL uses https://tinkerpop.apache.org/[Apache Tinkerpop] for Graph API.
Using this API gives support to https://tinkerpop.apache.org/providers.html[over twenty fives databases].
